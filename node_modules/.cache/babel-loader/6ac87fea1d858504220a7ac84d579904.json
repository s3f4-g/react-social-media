{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ActionTypes } from './useListbox.types';\nimport areArraysEqual from '../utils/areArraysEqual';\n/**\n * Gets the current state. If the selectedValue is controlled,\n * the `value` prop is the source of truth instead of the internal state.\n */\n\nfunction getControlledState(internalState, props) {\n  if (props.value !== undefined) {\n    return _extends({}, internalState, {\n      selectedValue: props.value\n    });\n  }\n\n  return internalState;\n}\n\nfunction areOptionsEqual(option1, option2, optionComparer) {\n  if (option1 === option2) {\n    return true;\n  }\n\n  if (option1 === null || option2 === null) {\n    return false;\n  }\n\n  return optionComparer(option1, option2);\n}\n/**\n * Triggers change event handlers (onChange and onHighlightChange) when reducer returns changed state.\n *\n * @param nextState The next state returned by the reducer.\n * @param internalPreviousState The previous state. If the component is controlled, this is merged with the props to determine the final state.\n * @param propsRef The props with defaults applied.\n * @param lastActionRef The last action that was dispatched.\n */\n\n\nfunction useStateChangeDetection(nextState, internalPreviousState, propsRef, lastActionRef) {\n  React.useEffect(() => {\n    if (!propsRef.current || lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n\n    if (lastActionRef.current.type === ActionTypes.setValue || lastActionRef.current.type === ActionTypes.setHighlight) {\n      // Don't fire change events when the value has been changed externally (e.g. by changing the controlled prop).\n      return;\n    }\n\n    const previousState = getControlledState(internalPreviousState, propsRef.current);\n    const {\n      multiple,\n      optionComparer\n    } = propsRef.current;\n\n    if (multiple) {\n      var _previousState$select;\n\n      const previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValue) != null ? _previousState$select : [];\n      const nextSelectedValues = nextState.selectedValue;\n      const onChange = propsRef.current.onChange;\n\n      if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {\n        onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValues);\n      }\n    } else {\n      const previousSelectedValue = previousState == null ? void 0 : previousState.selectedValue;\n      const nextSelectedValue = nextState.selectedValue;\n      const onChange = propsRef.current.onChange;\n\n      if (!areOptionsEqual(nextSelectedValue, previousSelectedValue, optionComparer)) {\n        onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValue);\n      }\n    } // Fires the highlightChange event when reducer returns changed `highlightedValue`.\n\n\n    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {\n      var _propsRef$current, _propsRef$current$onH;\n\n      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, lastActionRef.current.event, nextState.highlightedValue);\n    }\n\n    lastActionRef.current = null;\n  }, [nextState.selectedValue, nextState.highlightedValue, internalPreviousState, propsRef, lastActionRef]);\n}\n/**\n * @ignore - do not document.\n */\n\n\nexport default function useControllableReducer(internalReducer, externalReducer, props) {\n  var _ref;\n\n  const {\n    value,\n    defaultValue,\n    multiple\n  } = props.current;\n  const actionRef = React.useRef(null);\n  const initialSelectedValue = (_ref = value === undefined ? defaultValue : value) != null ? _ref : multiple ? [] : null;\n  const initialState = {\n    highlightedValue: null,\n    selectedValue: initialSelectedValue\n  };\n  const combinedReducer = React.useCallback((state, action) => {\n    actionRef.current = action;\n\n    if (externalReducer) {\n      return externalReducer(getControlledState(state, action.props), action);\n    }\n\n    return internalReducer(getControlledState(state, action.props), action);\n  }, [externalReducer, internalReducer]);\n  const [nextState, dispatch] = React.useReducer(combinedReducer, initialState);\n  const dispatchWithProps = React.useCallback(action => {\n    dispatch(_extends({\n      props: props.current\n    }, action));\n  }, [dispatch, props]);\n  const previousState = React.useRef(initialState);\n  React.useEffect(() => {\n    previousState.current = nextState;\n  }, [previousState, nextState]);\n  useStateChangeDetection(nextState, previousState.current, props, actionRef);\n  return [getControlledState(nextState, props.current), dispatchWithProps];\n}","map":{"version":3,"sources":["C:/Users/sefac/Desktop/yazılım/react-social-media/node_modules/@mui/base/ListboxUnstyled/useControllableReducer.js"],"names":["_extends","React","ActionTypes","areArraysEqual","getControlledState","internalState","props","value","undefined","selectedValue","areOptionsEqual","option1","option2","optionComparer","useStateChangeDetection","nextState","internalPreviousState","propsRef","lastActionRef","useEffect","current","type","setValue","setHighlight","previousState","multiple","_previousState$select","previousSelectedValues","nextSelectedValues","onChange","event","previousSelectedValue","nextSelectedValue","highlightedValue","_propsRef$current","_propsRef$current$onH","onHighlightChange","call","useControllableReducer","internalReducer","externalReducer","_ref","defaultValue","actionRef","useRef","initialSelectedValue","initialState","combinedReducer","useCallback","state","action","dispatch","useReducer","dispatchWithProps"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ActionTypes } from './useListbox.types';\nimport areArraysEqual from '../utils/areArraysEqual';\n\n/**\n * Gets the current state. If the selectedValue is controlled,\n * the `value` prop is the source of truth instead of the internal state.\n */\nfunction getControlledState(internalState, props) {\n  if (props.value !== undefined) {\n    return _extends({}, internalState, {\n      selectedValue: props.value\n    });\n  }\n  return internalState;\n}\nfunction areOptionsEqual(option1, option2, optionComparer) {\n  if (option1 === option2) {\n    return true;\n  }\n  if (option1 === null || option2 === null) {\n    return false;\n  }\n  return optionComparer(option1, option2);\n}\n\n/**\n * Triggers change event handlers (onChange and onHighlightChange) when reducer returns changed state.\n *\n * @param nextState The next state returned by the reducer.\n * @param internalPreviousState The previous state. If the component is controlled, this is merged with the props to determine the final state.\n * @param propsRef The props with defaults applied.\n * @param lastActionRef The last action that was dispatched.\n */\nfunction useStateChangeDetection(nextState, internalPreviousState, propsRef, lastActionRef) {\n  React.useEffect(() => {\n    if (!propsRef.current || lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n    if (lastActionRef.current.type === ActionTypes.setValue || lastActionRef.current.type === ActionTypes.setHighlight) {\n      // Don't fire change events when the value has been changed externally (e.g. by changing the controlled prop).\n      return;\n    }\n    const previousState = getControlledState(internalPreviousState, propsRef.current);\n    const {\n      multiple,\n      optionComparer\n    } = propsRef.current;\n    if (multiple) {\n      var _previousState$select;\n      const previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValue) != null ? _previousState$select : [];\n      const nextSelectedValues = nextState.selectedValue;\n      const onChange = propsRef.current.onChange;\n      if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {\n        onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValues);\n      }\n    } else {\n      const previousSelectedValue = previousState == null ? void 0 : previousState.selectedValue;\n      const nextSelectedValue = nextState.selectedValue;\n      const onChange = propsRef.current.onChange;\n      if (!areOptionsEqual(nextSelectedValue, previousSelectedValue, optionComparer)) {\n        onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValue);\n      }\n    }\n\n    // Fires the highlightChange event when reducer returns changed `highlightedValue`.\n    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {\n      var _propsRef$current, _propsRef$current$onH;\n      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, lastActionRef.current.event, nextState.highlightedValue);\n    }\n    lastActionRef.current = null;\n  }, [nextState.selectedValue, nextState.highlightedValue, internalPreviousState, propsRef, lastActionRef]);\n}\n\n/**\n * @ignore - do not document.\n */\nexport default function useControllableReducer(internalReducer, externalReducer, props) {\n  var _ref;\n  const {\n    value,\n    defaultValue,\n    multiple\n  } = props.current;\n  const actionRef = React.useRef(null);\n  const initialSelectedValue = (_ref = value === undefined ? defaultValue : value) != null ? _ref : multiple ? [] : null;\n  const initialState = {\n    highlightedValue: null,\n    selectedValue: initialSelectedValue\n  };\n  const combinedReducer = React.useCallback((state, action) => {\n    actionRef.current = action;\n    if (externalReducer) {\n      return externalReducer(getControlledState(state, action.props), action);\n    }\n    return internalReducer(getControlledState(state, action.props), action);\n  }, [externalReducer, internalReducer]);\n  const [nextState, dispatch] = React.useReducer(combinedReducer, initialState);\n  const dispatchWithProps = React.useCallback(action => {\n    dispatch(_extends({\n      props: props.current\n    }, action));\n  }, [dispatch, props]);\n  const previousState = React.useRef(initialState);\n  React.useEffect(() => {\n    previousState.current = nextState;\n  }, [previousState, nextState]);\n  useStateChangeDetection(nextState, previousState.current, props, actionRef);\n  return [getControlledState(nextState, props.current), dispatchWithProps];\n}"]},"metadata":{},"sourceType":"module"}